\chapter{Environment}
The chapter gives a description of the simulation environment we have created. Presenting how we created it, why we needed to create it and motivation of the choices made.\\
First we give an short overview of the parts that are in the enviroment, and a definition of in/out data. Motivating all our choices made concerning limitations in the enviroment, and also describing positive features of our enviroment.
\\
In order to attain measurable data do compare our different algorithms it is nessecary to construct a good testing enviroment. We decided to create an enviroment consisting of two separate parts. One part is called "map generator". This part creates a map, test the feasibility and prints feasible maps into an output file. The other part is called the "network generator". This part reads in an enviroment from a file, creates a graph network to the corresponding map and gives each node its relevant information. 
\\
\section{Generator}
The environment generator has length, width and number of obstacles as input. By construction each subarea is convex. The generator also tests for the total area to be connected, which guarantees a feasible environment.\\
\\
Every environment created can be considered to be built of squares. This results in that diagonal edges will not be created, but since a diagonal can be created by a line of obstacles if the resolution is high enough, that should not be a loss of generality. \\
\\
\\
\section{Node network}
The node network generator has a matrix that represents the environment as input. The matrix can either be generated by the simulation environment generator, se previous section, or written by hand.\\
\par{} A node network will be generated from the input matrix. Each element in the input matrix is represented by a node, which is given the attributes Vision, move and state. Vision is an array of all the nodes that can be seen from the current node, move is an array with the neighbour nodes to the current node.\\
\\
Pseudo-code:\\
* Read environment matrix from file\\
* Create a node-matrix B, and give each node a default state\\
* Calculate and set move and vision attributes for each node\\